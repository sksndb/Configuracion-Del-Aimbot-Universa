-- Centro Owen Xit | Aimbot + ESP (OPTIMIZADO FPS - SIN LAG CON MUCHOS JUGADORES)
-- Clave CONECTADA REMOTAMENTE a https://pastebin.com/raw/h7RQseud
-- Cambia la tecla editando SOLO ese pastebin, sin tocar este script
 
KeySystemEnabled local = verdadero
URL de clave local = "https://pastebin.com/raw/h7RQseud"
 
-- Descarga la clave remota (con fallback si falla internet o pastebin)
local CorrectKey = "fallback_key" -- por si no carga
pcall(funciÃ³n()
    respuesta local = juego:HttpGet(KeyUrl, true) -- true = sin cachÃ©
    si respuesta y respuesta ~= "" entonces
        ClaveCorrecta = respuesta:coincidencia("^%s*(.-)%s*$") o ClaveCorrecta
    fin
fin)
 
-- Archivo local para persistir (no pide clave cada salto de servidor)
Archivo de clave local = "owen_xit_key.txt"
 
funciÃ³n local LoadSavedKey()
    si isfile y isfile(KeyFile) entonces
        contenido local = readfile(KeyFile)
        devolver contenido:coincidencia("^%s*(.-)%s*$") o ""
    fin
    devolver cero
fin
 
funciÃ³n local SaveKey(tecla)
    Si escribe archivo entonces
        escribirarchivo(ArchivoClave, clave)
    fin
fin
 
clave guardada local = CargarClaveGuardada()
 
Si KeySystemEnabled y savedKey ~= CorrectKey entonces
    local ingresado = falso
 
    ScreenGui local = Instancia.new("ScreenGui")
    ScreenGui.Parent = juego.CoreGui
    ScreenGui.Name = "OwenKeyGui"
    ScreenGui.ResetOnSpawn = falso
 
    Marco local = Instancia.new("Marco")
    Marco.TamaÃ±o = UDim2.new(0, 300, 0, 180)
    Marco.PosiciÃ³n = UDim2.new(0.5, -150, 0.5, -90)
    Marco.ColorDeFondo3 = Color3.fromRGB(30, 30, 30)
    Marco.BorderSizePixel = 0
    Marco.Padre = ScreenGui
 
    TÃ­tulo local = Instancia.new("TextLabel")
    TÃ­tulo.TamaÃ±o = UDim2.new(1, 0, 0, 40)
    TÃ­tulo.Transparencia de fondo = 1
    TÃ­tulo.Texto = "Owen Xit Hub - Sistema de llaves (Remota)"
    TÃ­tulo.TextColor3 = Color3.fromRGB(255, 100, 100)
    TÃ­tulo.TextSize = 24
    TÃ­tulo.Fuente = EnumeraciÃ³n.Fuente.SourceSansBold
    TÃ­tulo.Padre = Marco
 
    cuadro de entrada local = Instancia.new("Cuadro de texto")
    InputBox.TamaÃ±o = UDim2.nuevo(0.8, 0, 0, 40)
    InputBox.Position = UDim2.new(0.1, 0, 0.3, 0)
    InputBox.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    InputBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    InputBox.PlaceholderText = "Ingresa la clave..."
    Cuadro de entrada.Texto = ""
    InputBox.Font = EnumeraciÃ³n.Font.SourceSans
    InputBox.TextSize = 18
    InputBox.Parent = Marco
 
    BotÃ³n de envÃ­o local = Instancia.new("BotÃ³n de texto")
    BotÃ³n de envÃ­o.TamaÃ±o = UDim2.nuevo(0.8, 0, 0, 40)
    BotÃ³n de envÃ­o.PosiciÃ³n = UDim2.new(0.1, 0, 0.55, 0)
    BotÃ³n de envÃ­o.ColorDeFondo3 = Color3.fromRGB(0, 170, 255)
    BotÃ³n de envÃ­o.TextoColor3 = Color3.fromRGB(255, 255, 255)
    SubmitButton.Text = "Verificar clave"
    BotÃ³n de envÃ­o.Fuente = EnumeraciÃ³n.Fuente.SourceSansBold
    BotÃ³n de envÃ­o.TextSize = 20
    BotÃ³n de envÃ­o.Padre = Marco
 
    Estado local = Instancia.new("TextLabel")
    Estado.TamaÃ±o = UDim2.new(0.8, 0, 0, 30)
    Estado.PosiciÃ³n = UDim2.new(0.1, 0, 0.8, 0)
    Estado.Transparencia de fondo = 1
    Estado.Texto = ""
    Estado.TextColor3 = Color3.fromRGB(255, 80, 80)
    Estado.TextSize = 16
    Estado.Fuente = EnumeraciÃ³n.Fuente.SourceSans
    Estado.Padre = Marco
 
    funciÃ³n local CheckKey(keyInput)
        si keyInput == CorrectKey entonces
            Guardar clave (entrada de clave)
            ingresado = verdadero
            Status.Text = "Â¡Clave correcta! Cargando... (guardada)"
            Estado.TextColor3 = Color3.fromRGB(0, 255, 100)
            esperar(1.5)
            ScreenGui:Destruir()
        demÃ¡s
            Status.Text = "Clave incorrecta. Intento de nuevo."
            Cuadro de entrada.Texto = ""
        fin
    fin
 
    InputBox.FocusLost:Conectar(funciÃ³n(enterPressed)
        Si se presiona Enter, entonces CheckKey(InputBox.Text) finaliza
    fin)
 
    BotÃ³n de envÃ­o.BotÃ³n del ratÃ³n1Clic:Conectar(funciÃ³n()
        CheckKey(Cuadro de entrada.Texto)
    fin)
 
    repetir la tarea.wait() hasta que se ingrese o no ScreenGui.Parent
    Si no se ingresa, regrese al final
fin
 
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
--GUIÃ“N PRINCIPAL
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 
Rayfield local = loadstring(juego:HttpGet('https://sirius.menu/rayfield'))()
 
Ventana local = Rayfield:CreateWindow({
   Nombre = "Owen Xit Hub",
   LoadingTitle = "El Mejor Hub Del Momento",
   LoadingSubtitle = "Cargando el mejor hub...",
   Guardado de configuraciÃ³n = {
      Habilitado = verdadero,
      NombreDeCarpeta = "RayfieldConfigs",
      Nombre del archivo = "OwenXitHub"
   },
   KeySystem = falso
})
 
local AimbotTab = Ventana:CreateTab("ğŸ¯ Aimbot", 4483362458)
VisualsTab local = Ventana:CreateTab("ğŸ¨ Visuals", 4483362458)
PestaÃ±aConfiguraciÃ³n local = Ventana:CrearPestaÃ±a("âš™ï¸ ConfiguraciÃ³n", 4483362456)
 
getgenv().ExunysDeveloperAimbot = {
   ConfiguraciÃ³n del desarrollador = {RainbowSpeed â€‹â€‹= 1},
   ConfiguraciÃ³n = {
      Habilitado = verdadero, TeamCheck = falso, AliveCheck = verdadero, WallCheck = falso,
      Sensibilidad = 0, Sensibilidad2 = 3.5, Modo de bloqueo = 1, Parte de bloqueo = "Cabeza",
      TriggerKey = Enum.UserInputType.MouseButton2, Toggle = falso
   },
   Ajustes de campo de visiÃ³n = {
      Habilitado = verdadero, Visible = verdadero, Radio = 90, NumSides = 60, Grosor = 1,
      Transparencia = 1, Relleno = falso, RainbowColor = falso, RainbowOutlineColor = falso,
      Color = Color3.fromRGB(255, 255, 255), ColorDeContorno = Color3.fromRGB(0, 0, 0),
      ColorBloqueado = Color3.fromRGB(255, 150, 150)
   },
   En la lista negra = {},
   FOVCircleOutline = Dibujo.new("CÃ­rculo"),
   FOVCircle = Dibujo.new("CÃ­rculo")
}
 
Env local = getgenv().ExunysDeveloperAimbot
Jugadores locales = juego:GetService("Jugadores")
RunService local = juego:GetService("RunService")
UIS local = juego:GetService("UserInputService")
ServicioTween local = juego:GetService("ServicioTween")
LP local = Jugadores.JugadorLocal
CÃ¡mara local = espacio de trabajo.CurrentCamera
 
Env.FOVCircle.Visible = falso
Env.FOVCircleOutline.Visible = falso
 
Distancia requerida local, mecanografÃ­a, ejecuciÃ³n, intervalo actual = 2000, falso, falso, nulo
Contador de fotogramas local = 0
 
Ajustes ESP locales = {
   Habilitado = falso, Casillas = verdadero, Trazadores = verdadero, Nombres = verdadero, Esqueleto = verdadero, Barras de salud = verdadero,
   TeamCheck = verdadero, ArcoÃ­ris = falso, Color = Color3.fromRGB(255, 0, 255),
   Grosor = 2, TamaÃ±o del texto = 16, Distancia mÃ¡xima = 300
}
 
objetos ESP locales = {}
Enlaces R15 locales = {{"Cabeza","Torso superior"}, {"Torso superior","Torso inferior"}, {"Torso inferior","Pierna superior izquierda"}, {"Pierna superior izquierda","Pierna inferior izquierda"}, {"Pierna inferior izquierda","Pie izquierdo"}, {"Torso inferior","Pierna superior derecha"}, {"Pierna superior derecha","Pierna inferior derecha"}, {"Pierna inferior derecha","Pie derecho"}, {"Torso superior","Brazo superior izquierdo"}, {"Brazo superior izquierdo","Brazo inferior izquierdo"}, {"Brazo inferior izquierdo","Mano izquierda"}, {"Torso superior","Brazo superior derecho"}, {"Brazo superior derecho","Brazo inferior derecho"}, {"Brazo inferior derecho","Mano derecha"}}
Enlaces R6 locales = {{"Cabeza","Torso"}, {"Torso","Brazo izquierdo"}, {"Torso","Brazo derecho"}, {"Torso","Pierna izquierda"}, {"Torso","Pierna derecha"}}
 
funciÃ³n local CreateESP(p)
   si ESPObjects[p] entonces devuelve fin
   carÃ¡cter local = p.CarÃ¡cter o p.CarÃ¡cterAÃ±adido:Espera()
   Si no es char entonces devuelve fin
   datos locales = {Enlaces = char:FindFirstChild("UpperTorso") y R15Links o R6Links}
   si ESPSettings.Boxes entonces datos.Box = Drawing.new("Square") datos.Box.Filled = false datos.Box.Transparency = 1 datos.Box.Thickness = ESPSettings.Thickness fin
   si ESPSettings.Tracers entonces datos.Tracer = Drawing.new("LÃ­nea") datos.Tracer.Thickness = 1.5 datos.Tracer.Transparency = 1 fin
   si ESPSettings.Names entonces datos.Nombre = Dibujo.new("Texto") datos.Nombre.Centro = verdadero datos.Nombre.Contorno = verdadero datos.Nombre.ColorContorno = Color3.new(0,0,0) datos.Nombre.Fuente = 2 datos.Nombre.TamaÃ±o = ESPSettings.TextSize datos.Nombre.Transparencia = 1 fin
   si ESPSettings.HealthBars entonces
      datos.HBBG = Dibujo.new("Cuadrado") datos.HBBG.Relleno = verdadero datos.HBBG.Color = Color3.new(0,0,0) datos.HBBG.Transparencia = 0.6
      datos.HB = Dibujo.new("Cuadrado") datos.HB.Relleno = verdadero datos.HB.Transparencia = 1
   fin
   datos.SkelLines = {}
   si ESPSettings.Skeleton entonces para _ = 1, #data.Links hacer local ln = Drawing.new("Line") ln.Thickness = 1.8 ln.Transparency = 0.7 table.insert(data.SkelLines, ln) fin fin
   datos.Resaltar = Instancia.new("Resaltar") datos.Resaltar.TransparenciaDeRelleno = 0.4 datos.Resaltar.TransparenciaDeContorno = 0 datos.Resaltar.Padre = CÃ¡mara
   ESPObjects[p] = datos
fin
 
funciÃ³n local RemoveESP(p)
   local d = ESPObjects[p] si no es d entonces devuelve fin
   si d.Box entonces d.Box:Remove() fin si d.Tracer entonces d.Tracer:Remove() fin si d.Name entonces d.Name:Remove() fin
   si d.HBBG entonces d.HBBG:Eliminar() fin si d.HB entonces d.HB:Eliminar() fin
   para _, l en ipairs(d.SkelLines o {}) hacer l:Remove() fin si d.Highlight entonces d.Highlight:Destroy() fin
   ESPObjects[p] = nulo
fin
 
funciÃ³n local GetClosestPlayer()
   local s = Env.Settings local visRad = Env.FOVSettings.Radius local intRad = 330 - visRad RequiredDistance = Env.FOVSettings.Enabled y intRad o 2000
   Local mÃ¡s cercano, dist = nulo, Distancia requerida
   para _, p en Jugadores:GetPlayers() hacer
      si p == LP entonces continÃºa fin local c = p.CarÃ¡cter local h = c y c:FindFirstChildOfClass("Humanoid")
      si no (c y h y h.Health > 0 y c:FindFirstChild(s.LockPart)) entonces continÃºa fin
      si s.TeamCheck y p.Team == LP.Team entonces continuar fin si table.find(Env.Blacklisted, p.Name) entonces continuar fin
      parte local = c[s.LockPart]
      si s.WallCheck entonces
         partes locales = LP.Character y LP.Character:GetDescendants() o {}
         para _, v en c:GetDescendants() hacer tabla.insert(partes, v) fin
         si #Camera:GetPartsObscuringTarget({part.Position}, parts) > 0 entonces continuar fin
      fin
      vector local, onScr = CÃ¡mara:WorldToViewportPoint(parte.PosiciÃ³n)
      local d = (UIS:GetMouseLocation() - Vector2.new(vec.X, vec.Y)).Magnitud
      si d < dist y onScr entonces dist = d MÃ¡s cercano = p fin
   fin
   Regresar mÃ¡s cercano
fin
 
RunService.Stepped:Connect(funciÃ³n()
   FrameCounter += 1 si FrameCounter % 3 ~= 0 entonces devuelve fin
   local f = Env.FOVSettings local s = Env.Settings local fc = Env.FOVCircle local fo = Env.FOVCircleOutline
   col local = Env.Locked y f.LockedColor o (f.RainbowColor y Color3.fromHSV(tick() % 5, 1, 1) o f.Color)
   Si f.Enabled y s.Enabled entonces
      fc.Radio = f.Radio fc.NÃºmero de lados = f.NÃºmero de lados fc.Espesor = f.Espesor fc.Transparencia = f.Transparencia fc.Relleno = f.Relleno fc.Visible = f.Visible fc.PosiciÃ³n = UIS:GetMouseLocation() fc.Color = col
      fo.Radio = f.Radio + f.Espesor fo.NÃºmero de lados = f.NÃºmero de lados fo.Espesor = f.Espesor + 1 fo.Transparencia = f.Transparencia fo.Visible = f.Visible fo.PosiciÃ³n = UIS:GetMouseLocation() fo.Color = f.RainbowOutlineColor y Color3.fromHSV(tick() % 5, 1, 1) o f.OutlineColor
   de lo contrario fc.Visible = falso fo.Visible = falso fin
   Si no es ESPSettings.Enabled, devuelve el final.
   para _, p en Jugadores:GetPlayers() hacer
      si p == LP entonces continÃºa fin local c = p.CarÃ¡cter raÃ­z local = c y c:FindFirstChild("HumanoidRootPart") hum local = c y c:FindFirstChild("Humanoid") cabeza local = c y c:FindFirstChild("Head")
      si no (raÃ­z y zumbido y cabeza y zumbido. Salud > 0) entonces RemoveESP(p) continuar fin
      dist local = (LP.Character y LP.Character:FindFirstChild("HumanoidRootPart") y (LP.Character.HumanoidRootPart.Position - root.Position).Magnitude) o 9999
      si dist > ESPSettings.MaxDistance entonces RemoveESP(p) continuar fin
      si ESPSettings.TeamCheck y p.Team == LP.Team entonces RemoveESP(p) continÃºa fin
      si no ESPObjects[p] entonces CreateESP(p) fin local d = ESPObjects[p]
      local rPos, onScr = Camera:WorldToViewportPoint(root.Position) si no estÃ¡ en onScr entonces d.Box.Visible = falso d.Tracer.Visible = falso d.Name.Visible = falso si d.HBBG entonces d.HBBG.Visible = falso d.HB.Visible = falso fin para _,l en d.SkelLines hacer l.Visible = falso fin d.Highlight.Enabled = falso continuar fin
      color local = ESPSettings.Rainbow y Color3.fromHSV((tick()*5 + p.UserId/255)%1,1,1) o ESPSettings.Color local vis = true
      si d.Box entonces d.Box.Visible = vis y ESPSettings.Boxes d.Box.Color = color local superior = CÃ¡mara:WorldToViewportPoint(head.Position + Vector3.new(0,0.5,0)) local inferior = CÃ¡mara:WorldToViewportPoint(root.Position - Vector3.new(0,4,0)) local h = math.abs(top.Y - bot.Y) local w = h*0.4 d.Box.Size = Vector2.new(w,h) d.Box.Position = Vector2.new(rPos.X - w/2, superior.Y) fin
      si d.Tracer entonces d.Tracer.Visible = vis y ESPSettings.Tracers d.Tracer.Color = color d.Tracer.From = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y*0.95) d.Tracer.To = Vector2.new(rPos.X, rPos.Y + 30) fin
      si d.Nombre entonces d.Nombre.Visible = vis y ESPSettings.Nombres d.Nombre.Color = color d.Nombre.Texto = p.Nombre.."\n"...math.floor(hum.Salud).." HP | "..math.floor(dist).."u" local hpos = Camera:WorldToViewportPoint(head.Position) d.Nombre.Position = Vector2.new(rPos.X, hpos.Y - 40) fin
      Si d.HBBG y d.HB entonces
         d.HBBG.Visible = vis y ESPSettings.HealthBars d.HB.Visible = vis y ESPSettings.HealthBars
         local superior = CÃ¡mara:WorldToViewportPoint(cabeza.PosiciÃ³n) local inferior = CÃ¡mara:WorldToViewportPoint(raÃ­z.PosiciÃ³n - Vector3.new(0,4,0)) local barH = math.abs(superior.Y - inferior.Y) local boxW = d.Box y d.Box.Size.X o 50
         d.HBBG.PosiciÃ³n = Vector2.nuevo(rPos.X + cajaW/2 + 6, superior.Y) d.HBBG.TamaÃ±o = Vector2.nuevo(4, barraH)
         perc local = hum.Salud / hum.SaludMÃ¡xima d.HB.Color = Color3.fromRGB(255*(1-perc), 255*perc, 0) d.HB.PosiciÃ³n = Vector2.nuevo(d.HBBG.PosiciÃ³n.X + 1.5, d.HBBG.PosiciÃ³n.Y + barH*(1-perc)) d.HB.TamaÃ±o = Vector2.nuevo(1, barH*perc)
      fin
      si d.SkelLines entonces para i, lÃ­nea en ipairs(d.SkelLines) hacer par local = d.Links[i] p1 local = c:FindFirstChild(pair[1]) p2 local = c:FindFirstChild(pair[2]) si p1 y p2 entonces v1 local = Camera:WorldToViewportPoint(p1.Position) v2 local = Camera:WorldToViewportPoint(p2.Position) lÃ­nea.From = Vector2.new(v1.X,v1.Y) lÃ­nea.To = Vector2.new(v2.X,v2.Y) lÃ­nea.Color = color lÃ­nea.Visible = vis y ESPSettings.Skeleton de lo contrario lÃ­nea.Visible = false fin fin fin
      d.Resaltar.Adornee = c d.Resaltar.ColorDeRelleno = color d.Resaltar.ColorDeContorno = color d.Resaltar.Habilitado = vis
   fin
fin)
 
RunService.Heartbeat:Connect(funciÃ³n()
   Si no estÃ¡ en ejecuciÃ³n o no estÃ¡ habilitado Env.Settings.Enabled o no estÃ¡ bloqueado, entonces regresa al final
   carÃ¡cter local = Env.Locked.Character parte local = char y char:FindFirstChild(Env.Settings.LockPart)
   si no es parte entonces si CurrentTween entonces CurrentTween:Cancel() CurrentTween = nil fin Env.Locked = nil Running = false retorno fin
   objetivo local = parte.PosiciÃ³n local scr = CÃ¡mara:WorldToViewportPoint(objetivo)
   si Env.Settings.LockMode == 2 entonces
      mousemoverel((scr.X - UIS:GetMouseLocation().X)/Env.Settings.Sensitivity2, (scr.Y - UIS:GetMouseLocation().Y)/Env.Settings.Sensitivity2)
   demÃ¡s
      si Env.Settings.Sensitivity > 0 entonces
         si CurrentTween entonces CurrentTween:Cancelar() fin
         CurrentTween = TweenService:Create(CÃ¡mara, TweenInfo.new(Env.Settings.Sensibilidad, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = CFrame.new(CÃ¡mara.CFrame.PosiciÃ³n, objetivo)})
         InterpolaciÃ³n actual: Reproducir()
      de lo contrario CÃ¡mara.CFrame = CFrame.new(CÃ¡mara.CFrame.PosiciÃ³n, objetivo) fin
   fin
fin)
 
UIS.InputBegan:Connect(funciÃ³n(entrada)
   Si escribe, devuelve fin local trig = Env.Settings.TriggerKey
   si input.UserInputType == trig o input.KeyCode == trig entonces
      si Env.Settings.Toggle entonces En ejecuciÃ³n = no En ejecuciÃ³n de lo contrario En ejecuciÃ³n = verdadero fin
      si se estÃ¡ ejecutando, entonces Env.Locked = GetClosestPlayer(); de lo contrario, si CurrentTween, entonces CurrentTween:Cancel() CurrentTween = nil fin Env.Locked = nil fin
   fin
fin)
 
UIS.InputEnded:Connect(funciÃ³n(entrada)
   si Env.Settings.Toggle o Typing entonces devuelve fin local trig = Env.Settings.TriggerKey
   si entrada.UserInputType == trig o entrada.KeyCode == trig entonces Running = false si CurrentTween entonces CurrentTween:Cancel() CurrentTween = nulo fin Env.Locked = nulo fin
fin)
 
UIS.TextBoxFocused:Connect(funciÃ³n() Typing = true fin)
UIS.TextBoxFocusReleased:Connect(funciÃ³n() Typing = false end)
Jugadores.EliminarJugador:Conectar(EliminarESP)
 
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- INTERFAZ CON FLAGS PARA GUARDAR CONFIGURACIÃ“N
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 
PestaÃ±a Aimbot:CrearAlternar({
   Nombre = "Habilitar Aimbot",
   ValorActual = verdadero,
   Bandera = "Aimbot_Enabled",
   DevoluciÃ³n de llamada = funciÃ³n(v) Env.Settings.Enabled = v fin
})
 
PestaÃ±a Aimbot:CrearAlternar({
   Nombre = "Control de equipo",
   ValorActual = falso,
   Bandera = "Aimbot_TeamCheck",
   DevoluciÃ³n de llamada = funciÃ³n(v) Env.Settings.TeamCheck = v fin
})
 
PestaÃ±a Aimbot:CrearAlternar({
   Nombre = "Campo de visiÃ³n arcoÃ­ris",
   ValorActual = falso,
   Bandera = "FOV_ArcoÃ­ris",
   DevoluciÃ³n de llamada = funciÃ³n(v) Env.FOVSettings.RainbowColor = v fin
})
 
PestaÃ±a Aimbot:CreateColorPicker({
   Nombre = "Color del cÃ­rculo FOV",
   Color = Color3.deRGB(255,255,255),
   Bandera = "FOV_Color",
   DevoluciÃ³n de llamada = funciÃ³n(c) Env.FOVSettings.Color = c fin
})
 
PestaÃ±a Aimbot:CreateSlider({
   Nombre = "TamaÃ±o del campo de visiÃ³n (1 = SUPER DESCARADO)",
   Rango = {1, 1000},
   Incremento = 5,
   ValorActual = 90,
   Bandera = "FOV_Radius",
   DevoluciÃ³n de llamada = funciÃ³n(v) Env.FOVSettings.Radius = v fin
})
 
PestaÃ±a Aimbot:CreateSlider({
   Nombre = "Suavidad (0 = instantÃ¡nea)",
   Rango = {0,1.5},
   Incremento = 0,05,
   ValorActual = 0,
   Bandera = "Aimbot_Suavidad",
   DevoluciÃ³n de llamada = funciÃ³n(v) Env.Settings.Sensitivity = v fin
})
 
PestaÃ±a Visuales:CreateToggle({
   Nombre = "Habilitar ESP",
   ValorActual = falso,
   Bandera = "ESP_Enabled",
   DevoluciÃ³n de llamada = funciÃ³n(v) ESPSettings.Enabled = v fin
})
 
PestaÃ±a Visuales:CreateToggle({
   Nombre = "Cajas",
   ValorActual = verdadero,
   Bandera = "ESP_Boxes",
   DevoluciÃ³n de llamada = funciÃ³n(v) ESPSettings.Boxes = v fin
})
 
PestaÃ±a Visuales:CreateToggle({
   Nombre = "Trazadores",
   ValorActual = verdadero,
   Bandera = "ESP_Tracers",
   DevoluciÃ³n de llamada = funciÃ³n(v) ESPSettings.Tracers = v fin
})
 
PestaÃ±a Visuales:CreateToggle({
   Nombre = "Nombres + HP + Dist",
   ValorActual = verdadero,
   Bandera = "ESP_Names",
   DevoluciÃ³n de llamada = funciÃ³n(v) ESPSettings.Names = v fin
})
 
PestaÃ±a Visuales:CreateToggle({
   Nombre = "Esqueleto",
   ValorActual = verdadero,
   Bandera = "ESP_Skeleton",
   DevoluciÃ³n de llamada = funciÃ³n(v) ESPSettings.Skeleton = v fin
})
 
PestaÃ±a Visuales:CreateToggle({
   Nombre = "Barras de salud",
   ValorActual = verdadero,
   Bandera = "ESP_HealthBars",
   DevoluciÃ³n de llamada = funciÃ³n(v) ESPSettings.HealthBars = v fin
})
 
PestaÃ±a Visuales:CreateToggle({
   Nombre = "Control de equipo",
   ValorActual = verdadero,
   Bandera = "ESP_TeamCheck",
   DevoluciÃ³n de llamada = funciÃ³n(v) ESPSettings.TeamCheck = v fin
})
 
PestaÃ±a Visuales:CreateToggle({
   Nombre = "Colores del arco iris",
   ValorActual = falso,
   Bandera = "ESP_ArcoÃ­ris",
   DevoluciÃ³n de llamada = funciÃ³n(v) ESPSettings.Rainbow = v fin
})
 
PestaÃ±a Visuales:CreateColorPicker({
   Nombre = "Color ESP",
   Color = Color3.deRGB(255,0,255),
   Bandera = "ESP_Color",
   DevoluciÃ³n de llamada = funciÃ³n(c) ESPSettings.Color = c fin
})
 
PestaÃ±a Visuales:CreateSlider({
   Nombre = "Grosor de lÃ­nea",
   Rango = {1,5},
   Incremento = 1,
   ValorActual = 2,
   Bandera = "ESP_Espesor",
   DevoluciÃ³n de llamada = funciÃ³n(v) ESPSettings.Thickness = v fin
})
 
PestaÃ±a Visuales:CreateSlider({
   Nombre = "TamaÃ±o del texto",
   Rango = {12,24},
   Incremento = 1,
   ValorActual = 16,
   Bandera = "ESP_TextSize",
   DevoluciÃ³n de llamada = funciÃ³n(v) ESPSettings.TextSize = v fin
})
 
-- PestaÃ±a de configuraciÃ³n
PestaÃ±a ConfiguraciÃ³n:BotÃ³nCrear({
   Nombre = "Guardar configuraciÃ³n ahora",
   DevoluciÃ³n de llamada = funciÃ³n()
      Rayfield:Guardar configuraciÃ³n()
      Rayfield:Notify({Title = "Guardado", Content = "ConfiguraciÃ³n guardada manualmente", Duration = 4})
   fin
})
 
PestaÃ±a ConfiguraciÃ³n:BotÃ³nCrear({
   Nombre = "Cargar ConfiguraciÃ³n",
   DevoluciÃ³n de llamada = funciÃ³n()
      Rayfield:CargarConfiguraciÃ³n()
      Rayfield:Notify({Title = "Cargado", Content = "ConfiguraciÃ³n cargada", Duration = 4})
   fin
})
 
PestaÃ±a ConfiguraciÃ³n:BotÃ³nCrear({
   Nombre = "Limpiar solo ESP",
   DevoluciÃ³n de llamada = funciÃ³n()
      para p en pares(ESPObjects) hacer RemoveESP(p) fin
      Rayfield:Notify({Title = "ESP Limpio", Content = "Todos los ESP removidos", Duration = 3})
   fin
})
 
PestaÃ±a ConfiguraciÃ³n:BotÃ³nCrear({
   Nombre = "Restablecer solo Aimbot",
   DevoluciÃ³n de llamada = funciÃ³n()
      si CurrentTween entonces CurrentTween:Cancelar() CurrentTween = nil fin
      Env.Locked = nulo En ejecuciÃ³n = falso
      Rayfield:Notificar({TÃ­tulo = "Restablecimiento de Aimbot", Contenido = "Bloqueo cancelado", DuraciÃ³n = 3})
   fin
})
 
-- Carga automÃ¡tica de configuraciÃ³n al iniciar (si existe)
Rayfield:CargarConfiguraciÃ³n()
 
print("Owen Xit Hub cargado - Clave remota: " .. KeyUrl .. " = " .. CorrectKey)
Rayfield:Notify({Title = "Â¡Bienvenido!", Content = "Key cargada desde Pastebin remoto\nFOV 30 = super descargado\nConfiguraciÃ³n ahora se guarda y carga", Duration = 8})
